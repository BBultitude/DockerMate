{% extends "base.html" %}
{% block title %}Dashboard - DockerMate{% endblock %}

{% block content %}
<div class="min-h-screen bg-slate-900" x-data="dashboardComponent()" x-init="init()">
    {% include 'components/navbar.html' %}

    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Header -->
        <div class="mb-8">
            <h2 class="text-3xl font-bold text-white">Dashboard</h2>
            <p class="mt-1 text-slate-400">Platform overview</p>
            <p class="text-xs text-slate-600 mt-1" x-text="'Last updated: ' + lastUpdated"></p>
        </div>

        <!-- =====================================================================
             COMPACT METRICS GRID  ‚Äî  Optimized layout (Task 4)
             ===================================================================== -->
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">

            <!-- Total Containers -->
            <div class="bg-slate-800 p-4 rounded-lg border border-slate-700">
                <p class="text-slate-400 text-xs mb-1">Total Containers</p>
                <p class="text-2xl font-bold text-white" x-text="stats.totalContainers"></p>
                <div class="flex items-center gap-1 mt-1">
                    <span class="text-xs text-slate-500">Capacity:</span>
                    <span class="text-xs font-medium"
                          :class="stats.capacityPercent > 80 ? 'text-red-400' :
                                  stats.capacityPercent > 60 ? 'text-yellow-400' : 'text-green-400'"
                          x-text="stats.capacityPercent + '%'"></span>
                </div>
            </div>

            <!-- Running Containers -->
            <div class="bg-slate-800 p-4 rounded-lg border border-slate-700">
                <p class="text-slate-400 text-xs mb-1">Running</p>
                <p class="text-2xl font-bold text-green-400" x-text="stats.runningContainers"></p>
                <p class="text-xs text-slate-500 mt-1">Active containers</p>
            </div>

            <!-- Stopped Containers -->
            <div class="bg-slate-800 p-4 rounded-lg border border-slate-700">
                <p class="text-slate-400 text-xs mb-1">Stopped</p>
                <p class="text-2xl font-bold text-slate-400" x-text="stats.stoppedContainers"></p>
                <p class="text-xs text-slate-500 mt-1">Inactive containers</p>
            </div>

            <!-- Hardware Profile -->
            <div class="bg-slate-800 p-4 rounded-lg border border-slate-700">
                <p class="text-slate-400 text-xs mb-1">Hardware</p>
                <p class="text-lg font-bold text-white truncate" x-text="hardware.profile_name || 'Loading...'"></p>
                <p class="text-xs text-slate-500 mt-1">
                    <span x-text="hardware.cpu_count + ' CPU'"></span> ‚Ä¢
                    <span x-text="hardware.total_memory_gb + 'GB'"></span>
                </p>
            </div>
        </div>

        <!-- Health Status Row -->
        <div class="grid grid-cols-1 mb-6">
            <div class="bg-slate-800 p-4 rounded-lg border"
                 :class="health.status === 'unhealthy' ? 'border-red-600' :
                         health.status === 'warning'   ? 'border-yellow-500' :
                                                         'border-slate-700'">
                <div class="flex items-center justify-between flex-wrap gap-4">
                    <!-- Status badge -->
                    <div class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-slate-300">System Health:</span>
                        <span class="text-xs font-semibold px-3 py-1 rounded-full"
                              :class="health.status === 'unhealthy' ? 'bg-red-900 text-red-300' :
                                      health.status === 'warning'   ? 'bg-yellow-900 text-yellow-300' :
                                                                      'bg-green-900 text-green-300'"
                              x-text="health.status.charAt(0).toUpperCase() + health.status.slice(1)"></span>
                    </div>

                    <!-- Health checks dots -->
                    <div class="flex gap-4 text-xs flex-wrap">
                        <template x-for="dot in healthDots" :key="dot.label">
                            <span class="flex items-center gap-1">
                                <span :class="dot.status === 'ok' ? 'text-green-400' : dot.status === 'warning' ? 'text-yellow-400' : 'text-red-400'">‚óè</span>
                                <span class="text-slate-400" x-text="dot.label"></span>
                            </span>
                        </template>
                    </div>

                    <!-- View details link -->
                    <a href="/health" class="text-xs text-blue-400 hover:underline whitespace-nowrap">
                        View details ‚Üí
                    </a>
                </div>
            </div>
        </div>

        <!-- =====================================================================
             PLATFORM OVERVIEW  ‚Äî  Environments  |  Images  |  Networks  |  Volumes
             ===================================================================== -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">

            <!-- Environment Distribution -->
            <div class="bg-slate-800 rounded-lg border border-slate-700 p-6">
                <h3 class="text-base font-semibold text-white mb-3">Environments</h3>
                <div x-show="stats.byEnvironment.length === 0" class="text-slate-500 text-sm">
                    No containers yet
                </div>
                <div x-show="stats.byEnvironment.length > 0" class="space-y-2">
                    <template x-for="env in stats.byEnvironment" :key="env.name">
                        <div class="flex items-center justify-between">
                            <span class="text-sm text-slate-300 uppercase" x-text="env.name"></span>
                            <span class="text-sm font-semibold text-white bg-slate-700 px-2 py-0.5 rounded" x-text="env.count"></span>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Images Summary -->
            <div class="bg-slate-800 rounded-lg border border-slate-700 p-6">
                <h3 class="text-base font-semibold text-white mb-3">Images</h3>
                <div class="flex items-end justify-between mb-3">
                    <div>
                        <p class="text-3xl font-bold text-white" x-text="images.count"></p>
                        <p class="text-xs text-slate-500 mt-0.5" x-text="'Total size: ' + images.totalSizeHuman"></p>
                    </div>
                    <div class="text-purple-400 text-2xl">üñºÔ∏è</div>
                </div>
                <!-- top 3 images by size -->
                <div x-show="images.top.length > 0" class="space-y-1 border-t border-slate-700 pt-2">
                    <p class="text-xs text-slate-500 mb-1">Largest</p>
                    <template x-for="img in images.top" :key="img.id">
                        <div class="flex items-center justify-between">
                            <span class="text-xs text-slate-300 truncate mr-2" x-text="img.name"></span>
                            <span class="text-xs text-slate-500 whitespace-nowrap" x-text="img.size"></span>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Networks Summary -->
            <div class="bg-slate-800 rounded-lg border border-slate-700 p-6">
                <h3 class="text-base font-semibold text-white mb-3">Networks</h3>
                <div class="flex items-end justify-between mb-3">
                    <div>
                        <p class="text-3xl font-bold text-white" x-text="networks.count"></p>
                        <p class="text-xs text-slate-500 mt-0.5">Active networks</p>
                    </div>
                    <div class="text-teal-400 text-2xl">üåê</div>
                </div>
                <!-- network list -->
                <div x-show="networks.list.length > 0" class="space-y-1 border-t border-slate-700 pt-2">
                    <template x-for="net in networks.list" :key="net.name">
                        <div class="flex items-center justify-between">
                            <span class="text-xs text-slate-300" x-text="net.name"></span>
                            <span class="text-xs text-slate-600" x-text="net.driver"></span>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Volumes Summary -->
            <div class="bg-slate-800 rounded-lg border border-slate-700 p-6">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-base font-semibold text-white">Volumes</h3>
                    <a href="/volumes" class="text-blue-400 hover:text-blue-300 text-sm">View all ‚Üí</a>
                </div>
                <div class="space-y-3">
                    <div class="flex justify-between">
                        <span class="text-slate-400 text-sm">Total</span>
                        <span class="text-slate-100 font-medium text-sm" x-text="volumes.total || 0"></span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-slate-400 text-sm">In Use</span>
                        <span class="text-green-400 font-medium text-sm" x-text="volumes.in_use || 0"></span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-slate-400 text-sm">Unused</span>
                        <span class="text-amber-400 font-medium text-sm" x-text="volumes.unused || 0"></span>
                    </div>
                </div>
            </div>
        </div>

    </main>
</div>

<script>
// ---------------------------------------------------------------------------
// Utility: format bytes ‚Üí human-readable string
// ---------------------------------------------------------------------------
function formatBytes(bytes) {
    if (!bytes) return '0 B';
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    const k = 1024;
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + units[i];
}

// ---------------------------------------------------------------------------
// Dashboard Alpine.js component
// ---------------------------------------------------------------------------
function dashboardComponent() {
    return {
        // --- state ---
        stats: {
            totalContainers: 0,
            runningContainers: 0,
            stoppedContainers: 0,
            capacityPercent: 0,
            byEnvironment: []
        },
        hardware: {
            profile_name: 'Loading...',
            cpu_count: 0,
            total_memory_gb: 0,
            max_containers: 0
        },
        health: {
            status: 'healthy',
            checks: { docker: 'ok', database: 'ok' },
            warnings: []
        },
        images: {
            count: 0,
            totalSizeHuman: '0 B',
            top: []          // [{name, size}] top 3 by size
        },
        networks: {
            count: 0,
            list: []         // [{name, driver}]
        },
        volumes: {
            total: 0,
            in_use: 0,
            unused: 0
        },
        lastUpdated: 'Never',
        loading: false,
        initialLoadComplete: false,  // Track if first load is done to prevent flashing on polling

        // Computed: one dot per check key, friendly labels, ordered
        get healthDots() {
            const labels = {
                docker: 'Docker', database: 'DB', containers: 'Containers',
                images: 'Images', networks: 'Networks', volumes: 'Volumes', dockermate: 'DockerMate'
            };
            const order = ['docker', 'database', 'containers', 'images', 'networks', 'volumes', 'dockermate'];
            return order
                .filter(k => this.health.checks[k] !== undefined)
                .map(k => ({ label: labels[k] || k, status: this.health.checks[k] }));
        },
        pollInterval: null,

        // --- lifecycle ---
        async init() {
            await this.loadAll();
            this.pollInterval = setInterval(() => this.loadAll(), 10000);
        },

        destroy() {
            if (this.pollInterval) clearInterval(this.pollInterval);
        },

        // --- fetch everything in parallel ---
        async loadAll() {
            // Only show loading spinner on initial load, not on polling refreshes
            if (!this.initialLoadComplete) {
                this.loading = true;
            }
            try {
                await Promise.all([
                    this.loadHardware(),
                    this.loadHealth(),
                    this.loadContainers(),
                    this.loadImages(),
                    this.loadNetworks(),
                    this.loadVolumes()
                ]);
                this.lastUpdated = new Date().toLocaleTimeString();
            } catch (e) {
                console.error('Dashboard load error:', e);
            } finally {
                this.loading = false;
                this.initialLoadComplete = true;  // Mark initial load as complete
            }
        },

        // --- individual loaders ---
        async loadHardware() {
            try {
                const r = await fetch('/api/system/hardware');
                if (!r.ok) return;
                const d = await r.json();
                if (d.success) {
                    // Only update if changed
                    if (JSON.stringify(this.hardware) !== JSON.stringify(d.data)) {
                        this.hardware = d.data;
                    }
                }
            } catch (e) { console.error('loadHardware:', e); }
        },

        async loadHealth() {
            try {
                const r = await fetch('/api/system/health');
                if (!r.ok) return;
                const d = await r.json();
                if (d.success) {
                    // Only update if changed (prevents DOM thrashing)
                    if (this.health.status !== d.status) this.health.status = d.status;
                    if (JSON.stringify(this.health.checks) !== JSON.stringify(d.checks)) {
                        this.health.checks = d.checks;
                    }
                    const newWarnings = d.warnings || [];
                    if (JSON.stringify(this.health.warnings) !== JSON.stringify(newWarnings)) {
                        this.health.warnings = newWarnings;
                    }
                }
            } catch (e) { console.error('loadHealth:', e); }
        },

        async loadContainers() {
            try {
                const r = await fetch('/api/containers?all=true&show_all=true');
                if (!r.ok) return;
                const d = await r.json();
                if (!d.success) return;
                const containers = d.data;

                // Only update primitives if they've changed
                const newTotal = containers.length;
                const newRunning = containers.filter(c => c.state === 'running').length;
                const newStopped = containers.filter(c => c.state !== 'running').length;

                if (this.stats.totalContainers !== newTotal) this.stats.totalContainers = newTotal;
                if (this.stats.runningContainers !== newRunning) this.stats.runningContainers = newRunning;
                if (this.stats.stoppedContainers !== newStopped) this.stats.stoppedContainers = newStopped;

                const max = this.hardware.max_containers || 100;
                const newCapacity = Math.min(100, Math.round((containers.length / max) * 100));
                if (this.stats.capacityPercent !== newCapacity) this.stats.capacityPercent = newCapacity;

                // group by environment - STABLE SORT by name (not count) to prevent flickering
                const groups = {};
                containers.forEach(c => {
                    const env = c.environment || 'UNTAGGED';
                    groups[env] = (groups[env] || 0) + 1;
                });
                const newByEnvironment = Object.entries(groups)
                    .map(([name, count]) => ({ name, count }))
                    .sort((a, b) => a.name.localeCompare(b.name));  // Stable alphabetical sort

                // Only update if changed (prevents unnecessary re-render)
                if (JSON.stringify(this.stats.byEnvironment) !== JSON.stringify(newByEnvironment)) {
                    this.stats.byEnvironment = newByEnvironment;
                }
            } catch (e) { console.error('loadContainers:', e); }
        },

        async loadImages() {
            try {
                const r = await fetch('/api/images');
                if (!r.ok) return;
                const d = await r.json();
                if (!d.success) return;

                const imgs = d.data;
                // Only update if changed
                if (this.images.count !== imgs.length) this.images.count = imgs.length;

                // total size
                const totalBytes = imgs.reduce((sum, i) => sum + (i.size_bytes || 0), 0);
                const newTotalSize = formatBytes(totalBytes);

                // top 3 by size - use image_id as stable key
                const newTop = imgs
                    .slice()
                    .sort((a, b) => (b.size_bytes || 0) - (a.size_bytes || 0))
                    .slice(0, 3)
                    .map(i => ({
                        id: i.image_id || i.id,  // Stable unique ID for :key
                        name: (i.repository || '<none>') + ':' + (i.tag || '<none>'),
                        size: formatBytes(i.size_bytes)
                    }));

                // Only update if changed
                if (this.images.totalSizeHuman !== newTotalSize) {
                    this.images.totalSizeHuman = newTotalSize;
                }
                if (JSON.stringify(this.images.top) !== JSON.stringify(newTop)) {
                    this.images.top = newTop;
                }
            } catch (e) { console.error('loadImages:', e); }
        },

        async loadNetworks() {
            try {
                const r = await fetch('/api/system/networks');
                if (!r.ok) return;
                const d = await r.json();
                if (!d.success) return;

                // Only update if changed
                if (this.networks.count !== d.count) this.networks.count = d.count;

                // STABLE SORT by name to prevent flickering
                const newList = (d.data || [])
                    .slice()
                    .sort((a, b) => (a.name || '').localeCompare(b.name || ''));

                // Only update if changed
                if (JSON.stringify(this.networks.list) !== JSON.stringify(newList)) {
                    this.networks.list = newList;
                }
            } catch (e) { console.error('loadNetworks:', e); }
        },

        async loadVolumes() {
            try {
                const r = await fetch('/api/volumes');
                if (!r.ok) return;
                const d = await r.json();
                if (!d.success) return;

                const vols = d.volumes || [];
                // Only update if changed
                const newTotal = vols.length;
                const newInUse = vols.filter(v => v.containers_using > 0).length;
                const newUnused = vols.filter(v => v.containers_using === 0).length;

                if (this.volumes.total !== newTotal) this.volumes.total = newTotal;
                if (this.volumes.in_use !== newInUse) this.volumes.in_use = newInUse;
                if (this.volumes.unused !== newUnused) this.volumes.unused = newUnused;
            } catch (e) { console.error('loadVolumes:', e); }
        }
    };
}
</script>
{% endblock %}
